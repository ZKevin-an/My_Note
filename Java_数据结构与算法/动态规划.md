# 动态规划
```
是求解决策过程最优化的过程
基本思想：将待解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解中得到原问题的解（分治算法）。
与分治算法不同的是因为分解的问题数目太多，如果直接对每个子问题都求解则会出现冗余时间复杂度太大，所以动态规划要求把之前每个子问题的解都记录下路，遇到冗余直接取出解使用，避免重复计算。
还可以直接从子问题开始一步步推到最终问题（而不是使用递归的方法）

动态规划三个重要概念：最优子结构，边界，状态转移公式
```

# 走楼梯问题
```
问题：有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。

解决思路：
走到第10级的走法 = 走到第9级的走法 + 走到第8级的走法
设F(n)为走到第n级台阶的走法
最优子结构：例如F(10)的最优子结构为F(9) + F(8);
边界：F(1) = 1;  F(2) = 2;
状态转移方程：F(n) = F(n-1) + F(n-2);

代码设计思路：
递归方法：F(n){...return F(n-1)+F(n-2)}
此方法的时间复杂度计算可以将其步骤列出，能够得到一个二叉树，把这个二叉树遍历完需要O(2^n)次操作，即时间复杂度为O(2^n)
备忘录方法：通过map或者哈希表，数组记录之前对每个子问题求解的记录，当遇到同样的子问题，直接取出即可，对于空时间复杂度都为O(n)（即为n个子问题，map长度为n）
动态规划：从子问题开始一步步向上求解，即直接求解，相当于从F(1)和F(2)开始，F(3)=F(2)+F(1),F(4)=F(3)+F(2)
其时间复杂度为O(n),空间复杂度为O(1)
```

# 黄金矿工
```
例如有5个金矿，每个金矿所需要的工人数不同，且产出的黄金数目也不同，现给你10个工人，问如何安排使获得的黄金数目最大

动态规划：
最优子结构：
1.5个金矿10个工人时的最优选择，4个金矿10-3个工人+第五个金矿产出黄金数目的最优选择
F(n,w) = max(F(n-1,w),  F(n-1,w-p[n-1])+g[n-1])    (n>1, w>=p[n-1])
2.当目前剩余人数小于该金矿所需人数，最优选择为剩下金矿的安排
F(n,w) = F(n-1,w)    (n>1, w<p[n-1])  
边界：
1.当只剩1个金矿且人数大于等于所需人数，则黄金数目即为产出
F(n,w) = g[0]     (n==1, w>=p[0]);
2.当只剩1个金矿且人数小于所需人数，则黄金数为0
F(n,w) = 0    (n<=1, w<p[0]);

代码解决思路：
1.递归：同样是O(n^2)的时间复杂度
2.备忘录算法：空间复杂度O(N*W) 时间复杂度O(n)
3.动态规划，创建一个数组，从边界条件开始一次向上遍历，空间复杂度为O(N*W)，时间复杂度O(n)。优化思路：因为目前的最优选择只和前一个矿的最优选择相关，可以创建一个2行的数组，每次更新即可。
```