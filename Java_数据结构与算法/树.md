# 二叉树
```
每个节点最多只能有两个子节点的树
满二叉树：所有叶子节点都在最后一层，且节点总数为2^n-1，n为层数
完全二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布
```

# 前序遍历、中序遍历、后序遍历
```
前序：先输出当前节点，再左节点，再右节点
中序：先左节点，输出当前节点，再右节点
后序：先左节点，再右节点，再输出当前节点
```

# 前序，中序，后续查找
```
顺序与遍历一致，只是将遍历的方法换成了查找的方式
```

# 删除节点（子树）
```
1.先当前树的根节点是否为要删除节点，如果是则直接header=null，否则进行下一步
2.对每个节点（包括根节点）进行：查看左子节点和右子节点是否为要删除节点，是则子节点直接置为null
3.如果不是，则对左右子节点继续调用删除函数（递归）
```

# 顺序储存二叉树
```
顺序储存二叉树通常只考虑完全二叉树
第n个元素的左子节点为2*n+1，右子节点为2*n+2，父节点为(n-1)/2
遍历方式：方式相同，只是对递归遍历加一个输入参数，即用2*n+1和2*n+2代替对左右子树的调用
```

# 线索二叉树
```
简单来说就是利用没有左右子树的节点的左右指针去指向他的前序和后序节点
目的：可以通过非递归的方式完成前中后序遍历，节省了递归所占用的空间
思路：多加了两个变量isLeft和isRight，确定子节点指向的是子节点还是前后序节点，并且在遍历之前需要对树进行线索化

线索化树：
1.按照所需的遍历方式进行（如中序遍历）先对自己的左子节点进行线索化（递归），
2.在查看当前节点的左节点是否为空，是则将前序节点设置为自己的左子树，并将isLeft置为1
（这里要注意是前序节点，所以需要设置一个pre临时节点用于在遍历过程中保存前序节点，当然在中序遍历中对于第一个子节点，其左子树指向任为null）
3.同时也要查看前序节点的右节点是否也为空，空则指向当前节点，并将isRight设置为1
4.在对自己的右子节点进行线索化（递归）

遍历线索化后的树：(中序遍历例子)
1.从头结点开始，寻找其左子树中isLeft中为1的点，即为中序遍历中开头的节点
2.找到后遍历其右子树，如果右子树都为Right==1则一直遍历下去，直到为0时
3.找到该isRight为0的节点时，再重复1（从当前节点开始）和2操作进行新一轮遍历
```

# 堆排序
```
大顶堆：每个节点的值都大于或等于其左右孩子节点的值
小顶堆：每个节点的值都小于或等于其左右孩子节点的值

堆排序基本思路：
1.将序列构成一个大顶堆
//从最后一个有子节点的节点开始，一步步往上重复构造一个大顶堆子树，直到根节点
for(int i=(arr.length-1-1)/2; i>=0; i--)
    Headadjust(arr, i, arr.length-1);

public static void Headadjust(int[] arr, int start, int end){
    int temp = arr[start];
    for(int i=start*2+1; i<=end; i=i*2+1){
        if(i+1<=end && arr[i] < arr[i+1]){ //比较左右子节点，取得最大值
            i++;
        }
        if(temp < arr[i]){      //将最大值与根节点进行对比，如果比根节点大则交换（注意这里不是交换，优化了操作）
            arr[start] = arr[i];
            start = i;
        }
        else{   //如果发现当前节点不需要交换，则可直接退出（因为遍历是从最小的子树开始的，如果上面的树都没有变动，则下面的子树肯定无需再变动）
            break;
        }
    }
    arr[start] = temp;  //完成最后的交换操作
}
2.将大顶堆的根节点（最大值）与末尾元素交换
3.将其他的n-1个元素重新构造成一个堆，再重新构建大顶堆，重复上述操作，最后得到一个有序序列
for(int i=0; i< arr.length-1; i++){  //进行n-1次的交换流程
    int temp = arr[0];
    arr[0] = arr[arr.length-1-i];
    arr[arr.length-1-i] = temp;
    Headadjust(arr, 0, arr.length-1-i-1); //每交换一次都要调整一次大顶堆，保证大顶堆正常
}
```

# 赫夫曼树
```
路径：一个节点到另一个节点间的通路
路径长度：节点所在层数减1
节点权：...
节点带权路径长度：路径长度与节点权的乘积
WPL（数的带权路径长度）：所有叶子结点的带权路径长度之和
赫夫曼树（最优二叉树）：构建这棵树的带权路径长度最小

构建哈夫曼树：
1.在n个权值中选出两个最小的权值，形成一个新的二叉树，新二叉树的根节点的权值为左右孩子权值之和
2.将原有的n个权值中删除那两个最小的权值，同时新的权值加入到n-2个权值中
3.重复1,2直到构建了一棵树为止
```

# 二叉排序树（二叉搜索树，二叉查找树）
```
1.左子节点值大于根节点的值
2.右子节点的值小于根节点的值
3.左右子树也是二叉排序树

特性：
1.中序遍历的序列是递增序列
2.平均查找效率O(logn)，最差查找效率O(n)(与插入时序列的顺序有关)

操作：
1.添加节点：从根节点开始比较每一个节点的值，然后一直到对应的空节点（叶子结点）添加进去
2.删除节点：
    1）如果是叶子节点，直接删除
    2）该节点只有左子树，直接又左子树替换上来
    3）只有右子树...
    4）左右子树都存在，从左子树中找到最大节点，或者从右子树找到最小节点，替换后将这些节点删除（转换为了删除叶子节点）
```

# 平衡二叉树(AVL)
```
用于解决二叉排序树中高度不确定的情况，导致搜索效率下降

性质：
1.左右子树高度差的绝对值小于等于1
2.左子树和右子树也是平衡二叉树
3.AVL树的高度为logn

操作：
BF：为了方便，给树的每一个节点附加一个数字，给出该节点左子树和右子树的高度差，称为节点的平衡因子（BF）
BF=节点左子树高度-节点右子树高度
插入：基本的插入方式与二叉排序树相同，但是每次插入之后要更新节点和其祖先节点的高度和BF，如果发现BF失衡，就要进行节点旋转
旋转：四种失衡（LL，LR，RR，RL）
    LL：节点BF2，左子节点BF1，则对节点进行右旋
    RR：节点BF-2，右子节点BF-1，则对节点进行左旋
    LR：节点BF2，左子节点BF-1，则对节点进行左旋，再右旋
    RL：节点BF-2，右子节点BF1，则对节点进行右旋，再左旋
    左旋：将子树根的右子节点的左指针指向根节点，根节点的右指针指向其右子节点的左子树，右子节点作为根
    右旋...
删除：删除方式与二叉排序树相同，然后看删除的方式计算父和祖先节点（递归可以很方便的达到效果）的BF，如果失衡，则可以等价于插入节点的方式进行旋转。不过这里有一个特殊情况，就是当删除的节点左右子树都存在时，在做右子树最小值或者左子树最大值替换的时候，遍历到这个最小值（最大值）的过程中，经历过的节点在最后都需要进行一次平衡计算
```

# B树（平衡多路排序树）
```
B树也就是B-树
产生原因：平衡二叉树对于数据存在磁盘的数据，去查找的过程中每一次都要进行一次IO操作，而对比于比较操作来说，IO操作时非常耗费时间的，所以对于数据库这样的系统来说如果内部储存使用平衡二叉树则每次查找会非常耗费时间，所以为了减小IO操作，将每个节点能够储存的数据数目增加，将整个树的高度压缩，从而减小IO操作（一个节点的存储空间可以等于磁盘中一个页的容量，如果超过了一个页则比较的过程中可能还需要再进行一次IO操作）
性质：
一个m阶B树，每个节点可以存放m-1个数据，可以包含m个指针，且除根节点外所有非终端节点至少有m/2棵子树，且所有叶子节点都在同一层上
插入和删除的过程中也会遵循叶子节点的要求的特点
```

# B+树（平衡多路增强排序树）
```
有些特性与B树都相同，不同点在于：
1.所有非叶子节点都保存信息的关键字，但是不保存具体内容，所有具体内容都保存在叶子节点处。
2.所有中间节点的元素都同时存在于子节点，在子节点元素中是最大（最小）元素
3.所有叶子节点使用指正按照顺序连接在一起
4.根节点为整个树中的最大元素，每次都出现在节点内容的最右端

相比与B树：
1.因为中间节点只包含关键字，则相比于B树，节点可以包含更多的指针，使得整体树高度较小，减少IO操作
2.可以保持查找的稳定性，相当于每次查找操作都要查询到叶子节点，次数都是一样的
3.适合范围操作，因为叶子节点通过指针互相连接，找到对应范围能够直接查找
```

# B*树
```
相比于B+树，为非叶子结点也增加了链表指针（在节点分裂转移数据的过程中提供了便利）
定义了非叶子节点关键字个数至少为2/3，即块最低使用率为2/3，相比于B+树提高了利用率
```

# 红黑树，2-3-4树
```
红黑树的概念：
2-3-4树是阶数为4的B树，而红黑树是对2-3-4树的一种实现，由于直接对节点进行2,3,4的转换会有大开销，所以红黑树以二叉树为基础，在二叉树中加入颜色属性来表示不同的2,3,4节点，其中2节点对应红黑树中的黑色节点，而红色节点+黑色节点表示3，4节点

红黑树的理解：
在左倾红黑树中将红色节点顺时针旋转45°使其与黑父平行，可以发现是一个2-3树，其主要重点还是在插入和删除的过程中，对节点进行2,3,4树转换和分裂...

红黑树的五条定义：
1.节点颜色有红和黑
2.根节点必为黑色（如果是2节点，则直接是黑色，如果是3,4节点可以用黑色节点表示其中一个元素作为根）
3.所有叶子节点都为黑色（因为叶子结点没有子节点，都为2节点，所以为黑色）
4.任意节点到每一个叶子结点经过的黑色节点数目相同（因为红色节点都是伴随黑色节点的，有一个红色节点就一定对应一个黑色节点，所以节点到叶子节点的路径上黑色节点数目相同，也就是说只有黑色节点+红色节点表示一个2,3,4节点，所以实际上只有黑色节点才会实际贡献高度）
5.不会有连续的红色节点

插入：
和平衡二叉树的插入过程一致，但是要遵循红黑树的五项原则，一般插入节点都标明为红色（因为插入后的红黑树一定不会破坏规则5），但是会违背规则2或4（但是修正的情况会比着色为黑色的情况少），所以需要修正其父节点，叔叔节点和祖父节点（往上类推）的颜色

```