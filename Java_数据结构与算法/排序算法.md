# 冒泡排序(bubble)
```
1.每一轮遍历都比较交换，最后的结果为最大的数到了数组的末端
2.每一轮遍历都可以少一个元素（最大的元素）
3.优化方法：当一轮遍历中没有元素交换，可以提前终止程序，表示已经排序完成
平均时间复杂度:O(n^2)
最差时间复杂度:O(n^2)
空间复杂度:O(1)
稳定度:稳定——如果遇到两个相同的元素，可以不交换，保证稳定性
Ps:n较小时好用
```

# 选择排序(select)
```
1.每一轮循环都从无序部分中挑选一个最小值，然后与有序部分最后一个元素的后一个元素进行交换
2.循环到无序部分只剩一个元素时完成
平均时间复杂度:O(n^2)
最差时间复杂度:O(n^2)
空间复杂度:O(1)
稳定度:不稳定——如果原本有两个相同元素并列排序，而且其他元素的交换的过程中(交换元素包含了其中一个元素)一定会打乱之前两个元素的前后关系
Ps:n较小时好用
```

# 插入排序(Insert)
```
1.每一轮都挑选无序部分中的第一个元素，然后插入到有序部分正确位置上
2.需要注意，每次插入有序部分的元素都要向后位移
平均时间复杂度:O(n^2)
最差时间复杂度:O(n^2)
空间复杂度:O(1)
稳定度:稳定——原本两个相同的元素，按照他们的前后顺序进行插入，则插入之后依然能够保持原先的前后顺序
Ps:大部分以排序时较好（引出希尔排序）
```

# 希尔排序(shell)
```
1.基本原理是先分组排序，最后整合
2.每次分组数目为上一轮分组数目的一半，第一次为数组长度的一半（即为两个元素为一组）
3.组内成员的挑选:元素之间相隔的间隔即为分组的数目（如分组为5，则元素挑选的间隔为5）
4.组内进行插入排序,直到元素间隔为1进行最后一次插入排序结束
平均时间复杂度:O(nlog2(n))
最差时间复杂度:O(n^(1.3~2))
空间复杂度:O(1)
稳定度:不稳定——当相同两个元素并列时，因为分组时两个元素分到了不同的组别，进行分组插入排序后两个元素的位置可能会发生变化（且无法避免），所以不稳定
```

# 快速排序(quick)
```
1.主要分为两个结构：partition 和 quickSort
2.partition：对数组进行分化，将数组分为大于中间和小于中间的两部分
    1)循环遍历，直到左指正和右指针指向同一个元素
    2)先从右指针开始（左指针也行），向左寻找小于中值数的值，找到后与中值置换（可以不交换，直接赋值，因为有暂存中值得临时变量）
    3)再从左指针开始，向左寻找大于中值数的值，找到后与中值置换(同上)
    4)分别置换一次后重复进行，直到左右指针指向同一个元素
    5)最后返回中值的位置（相当于把数组分为了两个部分）
3.quickSort：进行递归排序的部分
    1)先对给予的数组（左边界和右边界）找到其中值（调用partition方法）
    2)得到中值后，再对中值左右两边的数组分别调用quickSort进行递归
    3)当该函数被调用时发现被给予的左边界和右边界相等，则无需再进行
平均时间复杂度:O(nlog2(n))
最差时间复杂度:O(n^2)
空间复杂度:O(nlog2(n))
稳定度:不稳定——当有两个相同并列的数都比基准值大，需要与基准值交换，他们的相对位置就会发生改变
n大时较好
```

# 归并排序(merge)
```
1.同样需要递归，也分为两个结构merge和mergeSort
2.merge：合并两个有序数组，内容简单，要注意：
    1)输入为left，middle，right，用于标定限制两个有序数组的范围
    2)输入数组temp由于需要复用，数组长度可能会比此次使用的实际空间大，所以将temp复制回arr时注意temp的范围
3.mergeSort：用于递归调用，将数组划分之后进行归并
    1)第一步是将数组分为左右两个子数组，调用mergeSort函数
    2)将分开后两个有序数组进行归并，调用merge函数
    3)终止条件为left和right相遇
平均时间复杂度:O(nlog2(n))
最差时间复杂度:O(nlog2(n))
空间复杂度:O(n)
稳定度:稳定——在分治合并的过程中，可以通过小于等于号的条件保证在合并的过程中两个相同数的相对位置保持不变（这一点不好理解）
n大时较好
```

# 基数排序(radix)
```
1.找到最大的数值，确定所有元素中最大的位数
2.循环最大位数个数次，每一次都遍历所有元素，将每个元素放入对应的桶中（假设十个桶，分别代表0-9），并记录每个桶元素数目
3.遍历完一次后，将每个桶的元素依次取出，放回原数组中，再进行下一位位数的遍历
平均时间复杂度:O(logR(B))
最差时间复杂度:O(logR(B))，B为真数（0-9），R是基数（位数个数）
空间复杂度O(n)
稳定度:稳定——因为对于相同数字，会按照同样的顺序放入和取出桶，所以相对位置不会改变
```
