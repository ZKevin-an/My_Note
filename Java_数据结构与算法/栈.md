# 栈(Stack)
```
先入后出(FILO-First In Last Out)的有序列表
限制线性表中元素的插入和删除只能在线性表的同一端进行
变化的一端称为栈顶，另一端为栈底

应用场景：
1.子程序调用
2.处理递归
3.表达式转换（中缀表达式转后缀表达式）与求值
4.二叉树的遍历
5.图的深度优先(depth-first)搜索法
```

# 实现栈的思路
```
1.使用数组模拟栈：
定义top表示栈顶，初始化为-1
入栈：top++；stack[top] = data; //所以top始终指向栈顶元素
出栈：...

2.链表模拟栈：
1.top为栈顶指针，始终指向栈顶元素
...
```

# 前缀表达式，中缀表达式，后缀表达式
```
前缀表达式(波兰表达式)：运算符位于操作数之前
中缀表达式：常见的表达式(但对于计算机来说不好运算)
后缀表达式(逆波兰表达式）：运算符位于操作数之后
```

# 前缀表达式计算求值思路
```
1.从右至左扫描表达式
2.遇到数字压入栈
3.遇到运算符弹出两个数字做运算，并将结果入栈
4.直到表达式最左端，得到结果

PS：前缀表达式和后缀表达式的计算方法都很简单，所以可以将中缀表达式转换成前后缀表达式让计算机处理，但是中缀表达式转为前缀表达式的方法较难，所以一般采取中缀表达式转后缀的做法
PS：前后缀表达式都是遇到运算符直接出栈做运算的方式
```

# 中缀表达式计算求值思路
```
1.设置两个栈，分别存放数字和运算符
2.通过index遍历表达式
3.如果是数字直接压入数字栈(对于多位数，需要继续遍历后续表达式的内容，如果同为数字则算作多位数的一员，直到遇到一个运算符)
4.如果是符号：
    1）如果符号栈为空，直接压入
    2）如果符号优先级小于等于符号栈栈顶元素的优先级，则将符号栈的栈顶元素取出，并与数字栈栈顶的两个元素进行运算，得到的结果再入数字栈(注意这里没有涉及到括号运算符)
    3）如果优先级大于，则直接入栈
5.遍历完毕后，按顺序将数字栈和符号栈中的元素取出进行运算
6.最后数字栈只剩下一个数字，即为结果
```

# 后缀表达式计算求值思路
```
1.从左至右扫描表达式
2.遇到数字压入栈
3.遇到运算符弹出数字，计算得到结果后入栈
4.直到表达式最右端，得到结果
```

# 中缀表达式转换为后缀表达式
```
1.初始化两个栈：运算符栈s1和储存中间结果栈s2
2.从左至右扫描中缀表达式
3.遇到操作数时，压入s2中
4.遇到运算符时，比较与s1中栈顶元素的优先级
    1）若s1为空，或为左括号，直接入栈
    2）若优先级比栈顶元素高，直接入栈
    3）若小于或等于栈顶元素，栈顶元素出栈并压入s2中，再次回到4中重写对比新的s1栈顶元素
5.遇到括号
    1）如果是左括号，直接压入栈
    2）如果是右括号，依次弹出s1中的栈顶元素压入到栈s2中，直到遇到左括号为止，将这一对括号丢弃
6.直到遍历到表达式最右端
7.将s1中的剩余符号直接依次压入s2中
8.将s2逆序输出即为后缀表达式

PS:实际上数字一直是入栈操作，只是对于符号需要处理，即确定一个符号的优先级之后就可以判断入栈的顺序了，同时需要处理括号的优先级
```