# shell概述
```
shell是一个命令解释器，接收应用程序|用户命令，然后调用操作系统内核
通过编写shell脚本去操作系统做事情
Linux提供的shell解释器：cat /etc/shells
ls -l /bin/ | grep bash  查看系统默认的shell(sh)
echo $SHELL  查看系统默认的shell
```

# shell设置
```
新建文件：XXX.sh
脚本开头：#!/bin/sh：设置默认shell解析器
脚本编写：.......
脚本运行：
bash|sh + 脚本路径：sh/bash ./helloworld.sh
直接执行脚本（必须要有运行权限）：
chmod +x XXX.sh
./XXX.sh（必须要有./，要不然bash会认为XXX.sh是一个命令，然后去bin里面查找
通过source或.来执行：
source XXX.sh  |   .  XXX.sh
三者的区别：前两种都是通过生成一个子shell来运行shell脚本，而后一种则是通过当前的shell去执行脚本，前两种会导致环境变量的继承出现问题，比如父shell定义的局部变量在子shell中是不可见的
```

# 变量
```
变量按划分方式可分为两种：a)系统定义的变量，用户自定义的变量 b)全局变量，局部变量
env|printenv：查看当前的所有环境变量
set：查看当前定义的所有变量（包括了局部变量）
定义变量：变量名=变量值（不能有空格）通过这种方式定义的为局部变量
export 变量名：将变量提升成全局变量（但是在子shell中对全局变量的更改只在子shell中有用，不影响父shell，但是父shell中更改子shell能获得更改）
用户自定义变量建议小写
readonly 变量 = 变量值：设置只读变量，不用通过unset撤销或者修改
在bash中变量默认类型都是字符串类型，无法直接进行数值运算
```

# 特殊变量
```
$n：n为数字，$0代表脚本名称，$1-$9代表第1到9的参数，十以上的参数需要用大括号包含，如${10}
‘’与“”的区别：‘’内都会当做字符串，而“”则会解析其中的$
$#：获取所有输入参数的个数，无参数输入为0
$*：代表命令行中所有的参数，$*把所有参数看做一个整体
$@：同$*，不过$@把每个参数区分对待
$?：最后一次执行的命令的返回状态，上一个命令执行正确执行，返回0，如果执行不正确，则值为非0（由命令定义）
```

# 运算符
```
直接写a=1+2那a中保存的是'1+2'的字符串
$(()) | $[]：计算（2+3)*4----->  $[(2+3)*4]
目前一部分shell为了简化运算符操作，使用let可以直接使用常用的计算方式
```

# 条件判断if
```
test condition | [ condtion ]（注意一定有空格）：条件非空即为true
两个整数之间的比较
-eq(equal)：等于   -ne(not eqaul)：不等于
-lt(less than)：小于   -le(less equal)：小于等于
-gt(greater than)：大于  -ge(greater equal)：大于等于
字符串之间的比较：=和!=
文件权限判断：-r，-w，-x
文件类型判断：-e（存在），-f（存在并且是否是常规文件），-d（存在并且是目录）
多从条件判断：&&表示前一条命令执行成功才执行后一条，||表示上一个命令执行失败才执行下一条，所以使用[ condition ] && [ condition ] || [ condtion ]实现三元运算符？：

条件判断语句：
单分支：
if [ condition ]; then 
    程序 
fi
if [ condition ]
then
    程序
fi
多分支：
if [ condition ]
then
    程序
elif [ condition ]
then
    程序
else
    程序
fi
通过[ "$1"x == "XXX"x ]对输入参数进行判断能够防止无输入参数导致判断报错的情况
在[]内进行逻辑组合可以使用：-a(and)和-o(or)
```

# 条件判断case
```
case $变量名 in
“值1“)
    如果变量值等于值1，则执行程序1
;;
"值2")
    如果变量值等于值2，则执行程序2
;;
...
*)
    如果变量都没匹配上，则执行此程序
;;
esac
```

# 循环for
```
for (( 初始值;循环控制条件;变量变化 )) 
do
    程序
done
或：
for 变量 in 值1 值2 值3 ...
do
    程序
done
{1..100}：生成一个1到100的序列，比如可以for i in {1..100}
用for in去遍历$*和$@中的内容，得到的效果是一样的，但是使用“”之后就会不一样，$*会将内容当做整体处理，$@还是会分开
```

# 循环while
```
while [ condition ]
do
    程序
end
```

# read读取控制台输入
```
read 选项 参数
选项：
-p：指定读取值时的提示符
-t：指定读取值时等待的时间，不叫-t表示一直等待
参数：
变量：指定读取值的变量名
```

# 函数
```
sh脚本中函数的调用：
$(command)（命令替换）
常见的系统函数：
basename string|pathname suffix：删除所有的前缀，包括最后一个/，然后将字符串显示出来，suffix为后缀，会将指定的后缀去除
dirname 文件绝对路径：去除非目录部分字符，返回剩下的路径

自定义函数：
[ function ] funname[()]
{
    Action;
    [return int;]
}
实际上就是：
function add(){
    s=$[$1 + $2]
    echo ”和： "$s
}
在使用函数前必须在语句前声明函数，因为没有编译
函数返回值只能通过$?获得，return后面跟0~255，如果不加，则函数返回为最后一行命令的运行结果。
```

# 正则表达式
```
使用单个字符串来描述、匹配一系列符合某个语法规则的字符串
常规匹配：不含特殊字符的表达式来匹配，匹配所有包含该字符的行，例如：grep user
特殊字符：
^：匹配一行的开头，例如：grep ^a，匹配出所有以a开头的行
$：匹配一行的结束，例如：grep t$，匹配出所有以t结尾的行
.：匹配一个任意的字符，例如：grep r..t，会包含rabt，rbbt，root等的所有行
*：不单独使用，和上一个字符连用，表示匹配上一个字符0次或多次，例如：ro*t 会匹配rot，root，rooot等所用含
.*：任意字符串匹配多次
[]：匹配某个范围内的一个字符，例如：
[6,8]：匹配6或8
[0-9]：匹配一个0-9的数字
[0-9]*：匹配任意长度的数字字符串
[a-z]：匹配一个a-z之间的字符
[a-z]*：匹配任意长度的字母字符串
[a-c,e-f]：匹配a-c或e-f之间的任意字符
\：转义字符，不单独使用，用来表示特殊字符，如$,^等，需要用单引号括起来如'\$'
{}：和前面字符连用，连续出现的次数，例如"a{2}"，表示aa
+：和前面字符连用，匹配1到多次
?：和前面字符连用，匹配0或1次
```